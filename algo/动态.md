## 动态规划

**我们把问题分解为多个阶段，每个阶段对应一个决策。我们记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。**

解决动态规划问题，一般有两种思路，即**状态转移表法**和**状态转移方程法**。

状态转移表法: 我们先画出一个状态表。状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们将这个递推填表的过程，翻译成代码，就是动态规划代码了。

状态转移方程法: 类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，写出递归公式，也就是所谓的状态转移方程。有了状态转移方程，代码实现就非常简单了。

### 1.背包问题

我们有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？

我们把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个物品决策（放入或者不放入背包）完之后，背包中的物品的重量会有多种情况。

我们把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。我们可以通过合并每一层重复的状态，这样就保证每一层不同状态的个数都不会超过 w 个（w 表示背包的承载重量）。
我们用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。

第 0 个（下标从 0 开始编号）物品的重量是 2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 0 或者 2。我们用 states[0][0]=true 和 states[0][2]=true 来表示这两种状态。

第 1 个物品的重量也是 2，基于之前的背包状态，在这个物品决策完之后，不同的状态有 3 个，背包中物品总重量分别是 0(0+0)，2(0+2 or 2+0)，4(2+2)。我们用 states[1][0]=true，states[1][2]=true，states[1][4]=true 来表示这三种状态。

以此类推，直到考察完所有的物品后，整个 states 状态数组就都计算好了。图中 0 表示 false，1 表示 true。我们只需要在最后一层，找一个值为 true 的最接近 w（这里是 9）的值，就是背包中物品总重量的最大值。

```
def bag(capacity, items):
    n = len(items)  
    dp = [[-1]*(capacity+1) for _ in range(n)] #构造状态表
    dp[0][0] = 1 #填充第一行
    if items[0] <= capacity: #填充第一行
        dp[0][items[0]] = 1
        
    for i in range(1, n): #填充其他行
        for w in range(capacity+1):
            if dp[i-1][w] == 1:
                dp[i][w] = 1 #不放入背包
                if w + items[i] <= capacity: #放入背包
                    dp[i][w+items[i]] = 1
                    
    for w in range(capacity, -1, -1): #找出最大值
        if dp[-1][w] == 1:
            return w
```

### 2.最短距离问题

假设我们有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。我们将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？

画出一个二维状态表，表中的行、列表示棋子所在的位置，表中的数值表示从起点到这个位置的最短路径。我们按照决策过程，通过不断状态递推演进，将状态表填好。

```
def min_dist(w):
    m = len(w)
    n = len(w[0])    
    dp = [[None]*n for _ in range(m)] #构造状态表
    
    sum_ = 0
    for j in range(n): #填充第一行
        sum_ += w[0][j]
        dp[0][j] = sum_
        
    sum_ = 0
    for i in range(m): #填充第一列
        sum_ += w[i][0]
        dp[i][0] = sum_        
        
    for i in range(1, m): #填充其他单元格
        for j in range(1, n):
            dp[i][j] = w[i][j] + min(dp[i][j-1], dp[i-1][j])

    return dp[-1][-1] #返回最小值
```

### 3.编辑距离

编辑距离指的就是，将一个字符串转化成另一个字符串，需要的最少编辑操作次数（比如增加一个字符、删除一个字符、替换一个字符）。编辑距离越大，说明两个字符串的相似程度越小；相反，编辑距离就越小，说明两个字符串的相似程度越大。对于两个完全相同的字符串来说，编辑距离就是 0。

如果：a[i]!=b[j]，那么：min_edist(i, j)就等于：
min(min_edist(i-1,j)+1, min_edist(i,j-1)+1, min_edist(i-1,j-1)+1)

如果：a[i]==b[j]，那么：min_edist(i, j)就等于：
min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))

```
def edit_dist(s, t):
    m = len(s)
    n = len(t)
    dp = [[0]*n for _ in range(m)] #构造状态表

    for i in range(n): #填充第一行
        if s[0] == t[i]:
            dp[0][i] = i
        else:
            if i == 0:
                dp[0][0] = 1
            else:
                dp[0][i] = dp[0][i-1] + 1

    for i in range(m): #填充第一列
        if t[0] == s[i]:
            dp[i][0] = i
        else:
            if i == 0:
                dp[0][0] = 1
            else:
                dp[i][0] = dp[i-1][0] + 1
                
    for i in range(1, m): #填充其他单元格
        for j in range(1, n):
            dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, int(s[i] != t[j]) + dp[i-1][j-1])
            
    return dp[-1][-1] #返回最小值
	
s = "mitcmud"
t = "mtacnufgy"
print(edit_dist(s, t))
```
